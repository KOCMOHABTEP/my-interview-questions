Источник: https://www.youtube.com/watch?v=jrx_-R78fxs&ab_channel=%D0%9C%D0%B8%D1%88%D0%B0-FrontendDev  
05.02.2025  
ЗП: До 350к рублей

# Вопросы
1. JS Basic
2. JS Upper level
3. Web (браузер и тд)
4. Typescript
5. React
6. Redux и тд. (store)
7. Стилизация
8. Безопасность


## 1. Типы данных в Javascript?
Их 8. number, string, boolean, null, undefined, object, symbol, bigint  
Ссылочные и примитивные

### S: Ссылочные?
Object

### S: Что является массивом?
Индексированная коллекция данных, подвид объектов без ключей.

### S: Что из себя представляет объект?
key - string, sumbol
value - любой тип данных

## 2. Какие методы массива тебе приходят на ум?
push, pop, shift, map, filter, slice, splice

### S: Отличие map от forEach?
map создает новый массив с резуьтатом переданной функции
forEach просто итерируется

### S: Какая разница forEeach и цикл for?
for - break, continue
forEach 

### S: Что будет быстрее?
for быстрее, в forEach функцию передаем. Тяжелее из-за этого

## 3. Использовал ли some и every?
every - проверяет чтобы каждый элемент удовлетворял условию, возвращает true false  
some - проверяет чтобы хотя бы один элемент подходил под условие

## 4. Замыкание. Что это?
Комбинация лексического окружения и функции. Есть вложенная функция и внешняя функция и вложенная функция имеет доступ к переменной внешней функции, благодаря этому и замыкание происходит. 

### S: Что такое лексическое окружение?
Это скрытый объект и в нем есть ссылка на внешнее лексическое окружение и эти переменные которые объявлены в локально области видимости.

### S: Пример замыкания.
Кастомные хуки, там пишешь замыкание. Можно учесть что практически все создает замыкание.

### S: Как замыкание будет влиять на переполнение стека?
Могут быть утечки памяти, так как эти переменные сохраняются и не удаляются из памяти.

### S: Разница между Map,Set и WeakMap, WeakSet?
В WeakMap, в качестве ключей можно использовать только ссылочные типы данных. Если на этот объект не будет ссылок в коде, то он удаляется сборщиком мусора. Мы не можем итерироваться.

## 5. Что такое this и в чем отличие Function Declaration и стрелочной функции?
`this` - ссылка на объект, который владеет текущим исполняемым кодом  
В Declaration создают свой контекст, в стрелочных контекст берется выше, в стрелочных функциях не можем изменить через bind, call, apply

### S: В каком моменте происходит определение контекста?
В стрелочных функциях определяется в момент создания, а в обычных в момент вызова.

### S: В чем разница call, apply, bind?
Это способы перепрявязать контект у функции.  
Bind - создает функцию, которую мы передали. Не вызывается сразу, а создает обертку.  
Call, apply - вызывает функцию сразу с привязанным контекстом, разница между ними: `call` принимает аргументы через запятую, а `apply` в виде массива.

### S: Можно ли забайнднить несколько раз?
По идее нет, мы можем прописать цепочку bind, но сработает только первый контекст. 

## 6. Javascript однопоточный или многопоточный?
Однопоточный, но там можно с помощью WebWorker'ов отдельный поток создать.

### S: За счет чего механизм работает?
Event loop. Бесконечный цикл, который выполняет все задачи и распределяет их по очередям. Есть очередь микрозадач, макрозадач, и синхронный код.  
К микротаскам - promise, queueMicrotask, Mutation Observer.  
К макрозадачам - timeout, inverval, DOM-events.  
Порядок такой: сначала идет синхронный код, микрозадачи, потом 1 макрозадача берется и выполняется и так по кругу.

### S: Что имеет приоритет?
Больше микрозадачи. 

### S: Если очередь смешана. 
Получается сначала выполнится timeout, если он создал promise - то потом он выполнится. Все микротаски, а потом перейдет в выполнение макрозадач. 

### S: Какие причины блокировки Event-loop?
1. Синхронный скрипт тяжеловесный
2. Цепочка из 100 промисов. 

### S: Что слышал про синхронную и асинхронную рекурсию?
Синхронная рекурсия может заблокировать поток. И чтобы не блокировать поток можно выносить такие тяжелые скрипты в web воркеры.  
Можно разбивать на чанки.

## 7. Какая разница между Promise и Mutation Observer Api?
Promise - Поток, которое имеет строгое время выполнения.  
Mutation Observer - будет следить за элементом, пока ты сам не прекратишь.

### S: Был ли опыт с Mutation Observer?
Когда нужно было отслеживать измерение элементов.

## 8. Task1

# Browser
## 9. Какие отличие методов GET и POST?
По семантике:
1. GET для получения 
2. POST для создания

GET запросы могут кэшироваться браузером  
POST передаем body, в GET запросе если хотим что-то передать, то используем query параметры.

### S: К POSTу можно добавить query параметры?
Да, если backend их обработает. 

## 10. Что такое идемпотентность?
Если запросы идемпотентны - это те при одних и тех же аргументах, будет возвращать одно и тоже с бэкенда. 

### S: Может ли POST быть идемпотентным?
Нет, так как при создании сущностей будут разные IDшники 

### S: Что по длине строки URL?
Есть ограничения по количеству символов, в body нет ограничений.

## 11. Какие еще методы знаешь?
GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD

### S: Отличия PUT и PATCH?
1. PUT нужен для целого изменения ресурса
2. PATCH для частичного

### 12. Что такое заголовок Cookie?
Куки - ключ, значение до 4кб данных хранить, они будут пересылаться между сервером и клиентом, если мы так разрешим. Есть флаги для конфигурации куки:
1. HttpOnly
2. Secure
3. Expires
4. Max-Age

### S: Доступен ли куки с клента ?
Да, если `HttpOnly=false`, через document.cookie. 

### S: Увижу ли я 2 раза данные в куке, которые перезаписал сервер при запросе?
Будут отображаться только те, которые пришли с сервера.  
Она можно сказать serverFirst.

## 13. Какие еще есть хранилища в браузере?
1. IndexDB
2. SessionStorage
3. LocalStorage

### S: В чем разница SessionStorage и LocalStorage?
Оба могут хранить по 5МБ данных.   
SessionStorage после закрытия браузера очищается, а данные LocalStorage будет оставаться в браузере, даже после закрытия браузера. 

### S: Что такое IndexDB?
Асинхронная БД в браузере, там можно хранить больше данных чем в LocalStorage. 

# React.js

## 14. useEffect, useLayoutEffect - в чем разница?
1. useEffect - асинхронный. Выполняется после отрисовки.
2. useLayoutEffect - синхронный, может заблокировать рендер. Выполняется когда DOM дерево построилось, но еще не отобразились элементы и компоненты.  

useEffect - нужен для того, чтобы выполнять какие-то сайд эффекты, типа запроса на сервер. У этих 2ух хуков есть массив зависимостей.   
Если пустой массив зависимостей, то отработает при монтировании.  
Если с элементами, то при изменении элементов.  
Если никакой массив не передали, то при каждом рендере. 

## 15. Какие причины ререндера в React?
1. Изменение стейта
2. Изменение пропсов
3. Изменение контекста
4. Ререндер родительского компонента
5. Изменение ключей

### S: Какие практики есть для оптмизации ререндера?
Мемоизация компонентов, memo, useCallback, useMemo.
React.memo - сравнивает пропсы компонентов, если пропсы не изменились, то и не произойдет ререндера.  
Если не указать сравнение пропсов, по дефолту, под капотом идет поверхностное сравнение пропсов, и если пропсы не изменились, то тогда и не будет ререндера.   
useMemo - нужен для тяжелых вычислений, принимает callback и мемоизирует возвращаемое значение. Также есть массив зависимостей при которых будет происходить перерасчет этого всего.  
useCallback - для мемоизации функций, принимает callback и сохраняет ссылку на эту функцию.
Мемоизацию не стоит использовать везде. И useCallback стоит использовать если мы какую-то функцию передаем через пропсы компоненту, который обернут в React.memo, либо передаем функцию в массив зависимостей другим хукам.  

## Task2: React
## Task3: React

## 16. Что такое порталы?
Нужны для модальных окон, тултипов, чтобы отрисовать какой-то компонент вне родительского компонента. Обычно в document.body месте, и не было проблем с z-index.  

## 17. Что такое контекст?
Чтобы создать глобальное состояние в React без всяких State-менеджеров, избежать props-drilling. При изменении контекста изменяются все его "дети". 

### S: А как избежать этого? 
Замемоизировать их. 

### S: Мы создали useContext? Куда его добавить?
Вызываем useContext, туда передаем название контекста. Потом оборачиваем часть приложения в Context.Provider где мы хотим использовать этот контекст. 

### S: Что такое Context.Consumer?
Потребитель контекста. Также часть приложения оборачивается в Consumer, внутри него можем использовать значение контекста.

### S: Какой паттерн используется у Consumer?
Props render

### 18. Что такое рефы?
Обычно - чтобы ссылки на DOM элементы сохранять, либо мы можем какие-то значения сохранять. Основная фишка, что изменения ref.current не тригеррит ререндер.  

# State Managers
## 18. Какие знаешь?
Redux, Mobx, Effector. 

### S: React-Query в чем разница?
1. Кеширование продвинутое настраивать
2. Другой механизм работы с данными (useQuery, useMutation) 
3. Инвалидация
4. Огромное количество пропсов для манипулирования параметрами запросов

А в чем минусы?
1. Больше бизнес логики в компонентах появляется. Решается кастомными хуками.
2. Очень тяжелый
3. Больше работает с сетевыми запросами

### S: Знаком с концепцией tree-shaking?
В целом да, когда удаляются ненужные import из бандла. 

# Оптимизация
1. Tree-shaking - с помощью бандлеров решается (webpack, vite) 
2. Плагины для оптимизации и лоадеры для минимизации файлов. 
3. ServiceWorker для кеширования запросов.
4. Lazy-loading
5. Code\splitting
6. Виртуализация списков
7. Пагинации
8. debounce, trottle
9. Сжатие статики и вынес на CDN сервера

## 19. Задача: Web-vitals.
Есть сайт-слайдер с картинками, слайдер на весь экран, 10 картинок. Как оптимизировать?
1. Грузить не все картинки, а только ту которая сейчас на весь экран. Добавить Lazy-loading для картинок.
2. ProgressiveLoading, сначала в плохом качестве грузится, потом в хорошем. 
3. Сжать изображение, webp формат использовать. (браузеры разные, webp не все тянут, можно сделать теги <picture>)
4. Сайт адаптивный и можно использовать imgSet

### S: Что такое srcSet?
Передаем коллекцию для разных разрешений изображений

# Стилизация
## 20. Какие способы стилизации ты знаешь/применял?
CSS-IN-JS, CSS, CSS Modules, препроцессоры

### S: В чем отличие CSS модули и CSS-IN-JS?
CSS-IN-JS - хуже производительность делать, тк перед подгрузкой приложения - распарсить этот JS и перевести в стили. Используют для удобства стилизации.  
CSSModules - уникальные имена классы генерировать, чтобы избежать конфликтов (есть scope). Разбиваются на чанки.

# Typescript
## 21. Какие плюсы у Typescript и минусы?
Плюсы - выявлять ошибки на этапе разработки, ускоряется разработка за счет знания какие типы данных используются.  
Минусы - не защищает от ошибок в рантайме.

Он ускоряет поддержку кода, но не ускоряет написание фич. Кодогенерация - решает эту задачу.   

## 22. Какие Utulity Types используешь? 
Record, Pick, Omit, Required, Partial, Return Type, Awaited.  
Позволяют сократить количество дублированного кода, или как в Pick - извлечь поля, Omit - убрать.

## 23. ЧТо такое generic?
Чтобы создать переиспользуемый тип.

## 24. Что такое unknown и any?
any - отключает типизацию, может приводить к ошибкам.  
unknown более безопасный из-за того что он не позволит обращаться к каким то свойствам переменной, либо вызывать ее. 

# Вопросы к собеседующему
1. Вопрос по процессу.
2. Пишете ли тесты?
3. 