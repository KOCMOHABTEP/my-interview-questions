Источник: https://www.youtube.com/watch?v=sGcLJ-YBKL8&ab_channel=%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D0%BE%D0%B5%D0%B0%D0%B9%D1%82%D0%B8  
09.02.2025  
ЗП: До 350к рублей

# Вопросы
## 1. Что происходит когда пользователь ввел поисковый запрос в адресную строку браузера до момента начала отрисовки страницы?
Когда пользователь нажимает Enter, браузер отправляет GET запрос на ближайший DNS сервер, где по адресу определяется по какому ip адресу ему нужно стучаться. Далее сервер нам отдает html страничку, браузер начинает парсить HTML код, если встречает ссылки на стили, скрипты то также начинает их запрашивать, далее происходит Critical Rendering Path:
1. Браузер создает DOM дерево
2. Браузер создает CSSOM дерево
3. Далее он их компанует (вроде это называется render tree)
4. Layout стадия. На основе всех объектов начинает рассчитывать как будет выглядеть страничка по ширине экрана, как будет выглядеть компановка элеменов
5. Painting стадия. Когда браузер показывает страничку человеку и человек доволен. 

## 2. Что такое ошибка CORS, как исправить? 
CORS - Механизм создан для того чтобы помешать злоумышленникам отправлять поддельные запросы. Он проверяет ip клиента и проверяет соответствие в этого ip в своем whitelist на сервере. Если получаем такую ошибку, то надо настроить этот whitelist на бэке. 

## 3. Что такое cookie?
Механизм позволяет серверу сохранять какую инфу на клиенте. Это текстовые файлики, которые браузер сохраняет на диски и привязаны к определенному URL и туда можем записать токены какие-то, чтобы при повторном посещении страницы ее считать или отправить запросом. 

### S: Можем ли мы с cookie работать из JS? 
Куки можно создавать с помощью JavaScript, используя DOM-свойство Document.cookie. Также можно читать куки из JavaScript, если не был установлен атрибут HttpOnly.

# Javascript
## 4. В чем разница const от var?
Область видимости, у них функциональная область видимости. У var происходит всплытие переменной, то есть если мы выведем console.log до ее объявления, то будет undefined. А если let, const - то будет ошибка.

## 5. В чем различие stopPropagation и stopImmediatePropagation?
stopPropagation - метод останавливет распространение события, а stopImmediatePropagation - на этом элементе обработчик сработает, а далее нет

## 6. Какие стадии у DOM события существуют?
1. Погружение
2. Targeting
3. Всплытие

## 7. Чем обычная функция отличается от стрелочной?
Обычная функция берет контекст вызова в момент вызова функции и берет его из внешнего объекта. А в стрелочной функции у нее нет контекста вызова, при этом запоминает контекст при его создании. Их создавали с целью как callback'и 

### S: А можно изменить контекст у стрелочной функции?
Не можем. У обычных bind, apply, call.

## 8. Как создать копию объекта?
Метод structedClone, lodash.deepClone(), JSON.parse/JSON.stringify, Object.assign()

## 9 Что такое Event-Loop?
Механизм в JS, который дает возможность асинхронности. JS - язык однопоточный, синхронный.  
Сначала выполняются синхронные команды, есть 2 очереди (макротаски, микротаски). Сначала микротаски, 1 макротаску, потом еще смотрит очередь микротаски. 

### S: Что будет если макротаска будет создавать рекурсивно макротаску?
Заблокируется поток.

## 10. TASK1 - Promises
```javascript
// Что будет выведено в консоль?

console.log('start');

setTimeout(() => {
  console.log('setTimeout');
}, 0);

const promise = new Promise((resolve) => {
  console.log('promise1');
  resolve('resolve');
});

promise
  .then((data) => {
    console.log(data);
  })
  .then(() => {
    console.log('promise2');
  });

console.log('end');
// start
// promise1
// end
// resolve
// promise2
// setTimeout
```
## 11. TASK2 - Promises
```javascript
// Что будет выведено в консоль?
console.log('start');

Promise.resolve().then(() => {
  console.log('promise1');
  setTimeout(() => {
    console.log('timer2');
  }, 0);
});

setTimeout(() => {
  console.log('timer1');
  Promise.resolve().then(() => {
    console.log('promise2');
  });
}, 0);

// start
// promise1
// timer1
// promise2 
// timer2
```

# React
## 12. Что такое JSX?
JSX - синтаксис, который предоставляет React, чтобы удобней было писать код. 

## 13. Какие хуки знаешь?
1. useState
2. useEffect
3. useCallback
4. useMemo
5. useReducer
6. useContext
7. useRef

### S: Зачем нужно возвращать функцию из useEffect? 
Для очистки, чтобы не было утечек памяти, при размонтировании. 

### S: Только при unmount работает?
При unmount компонента, а также при ререндерах. 

## 14. Поподробнее про оптимизацию рендера.
1. Можем обернуть в React.memo для отпимизации рендера, если пропсы приходящие в него не будут меняться, то этот компонент не будет перерендериваться, даже если родительский компонент перерендерился.  
2. useCallback - тот же экземпляр функции не пересоздавая ее каждый раз
3. useMemo - 

### S: Как можно сделать без useCallback/useMemo сделать чтобы дочерний компонент без пропсов не рендерился. 
Можем его как children передать.  
Второй аргумент у memo - функция кастомной проверки пропсов.

## 15. Сколько рендеров вызовется вызов двух setState подряд?
1 рендер, так как есть такая штука как batching - объединяет асинхронные вызовы, чтобы лишний раз не делать перерендеры.

### S: В setState можем передать callback, зачем?
Для таких случаев, когда нам может понадобится изменение двух useState, и как раз в prevState получаем актуальное значение и можно с ним что-то сделать. 

## 16. Зачем нужен проп key?
Нужен для списков в React, если это динамический список, в котором мы можем элементы добавлять, удалять. У реакта нету других инструментов кроме key, чтобы определить какой элемент мы убираем, добавляем. Мы ориентируемся на этот атрибут.

## 17. Что такое порталы?
Возможность строить компоненты React в определенном месте нашего DOM дерева.

## 18. Что такое контекст? 
Возможность передать какие-то данные от родительского компонента к дочернему, минуя цепочку пропсов (prop drilling).  
Применение: язык поменять, тему поменять. 

### S: Какие проблемы есть все хранить в контексте?
Не очень хорошо с перерендерами, не очень хорошая оптимизация перерендеров. Могут возникать лишние перерендеры.

## 19. Что такое Virtual DOM?
Объектная модель, которую строит React, строит поверх реального DOM для себя, потому что реальный DOM - тяжеловесная модель, а Virtual DOM более легковесная модель. Сначала все изменения просчитывает на этом Virtual DOM, потому что это быстрее, а применяет изменения точечно уже на реальном DOM.

### S: На основе чего он так делает?
Там сложный алгоритм, куча оптимизация. Reconcilation.  React fiber.

## 20. ТЕОРИЯ. Проблемы производительности в Реакте и как их решать

# CSS
## 21. Какие виды позиционирования существуют?
static (по умолчанию), absolute, relative, sticky
1. static - по умолчанию, в потоке
2. relative - можем сдвинуть относительно положения, при этом из потока не вырываем, смещается
3. absolute - вырываем его из потока, можно сказать на следующий слой переносим,
4. fixed - чтобы всегда по центру была, так же как absolute, только не зависит от скролла
5. sticky - что-то среднее между absolute и sticky (прилипает к окошку)

### S: От чего позиционируется absolute элемент?
Относительно окна, либо если у родительских есть элементы с position: relative/absolute, то относительно их.

## 22. Что такое псевдоклассы?
hover, active, checked, before, after - дополнительная приписка к нашему селектору, которая может срабатывать при определенных статусах элементов. 

### S: А чем отличаются псевдоэлементы?
before, after - можем как будто создать тег на странице. Он отсутствует в DOM дереве, но ведет себя как реальный элемент.

## 23. В чем разница между span и div элементом?
span - срочный элемент, div - блочный. Блочный элемент занимает всю ширину страницы по умолчанию. А строчный элемент занимает ширину контента. И что-то с паддингами у строчных элементов. 

## 24. Как мы можем разместить элементы в линию?
Строчные элементы - и так идут в линию. Блочные - display: flex, inline, inline-block

## 25. Как отцентровать элемент внутри? 
display: flex, align-content: center, justify-content:center

## 26. Что такое специфичность?
Для каждого селектора вычисляется специфичность - тег, id, class. И каждый способ имеет свой приоритет, самый приоритетный
1. inline (инлайн стили на первом месте всегда)
2. id
3. class
4. tag
5. *(звездочка)
На основе этого рассчитываются какие способы будут перезаписывать какие. 

## 27. TASK3 - Алгоритмы
```javascript
// Написать функцию которая проверяет строку на содержание в ней всех букв из списка ABC...Z

const foo = (str) => {
    const list = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const hash = {};

    for (const l of list) {
        hash[l] = 0;
    }

    for (const l of str) {
        hash[l] = 1;
    }

    console.log(hash)

    return [...Object.values(hash)].every(el => el)
};

// const foo = (str) => {
//     const list = 'ABCD';
//     const hash = {};
//
//     for (let l in list) {
//         hash[l] = 1;
//     }
//
//     for (l in str) {
//         if (hash[l]) {
//             hash[l] = 0;
//         }
//     }
//     return [...Object.values(hash)].some(el => el)
// };

```

## 28. TASK4 - Алгоритмы2
```typescript
// Написать реализацию функции validateBrackets(brackets: string): boolean
// Функция должна проверять, что каждая из открытых скобок, закрыта соответствующей скобкой


function isValid(s: string): boolean {

    const bracketsMap = {
        ')': '(',
        ']': '[',
        '}': '{'
    }

    let openBracketsStack = []

    for (let i = 0; i < s.length; i++) {
        const currentBracket = s[i]

        if (['(', '[', '{'].includes(currentBracket)) {
            openBracketsStack.push(currentBracket)
        } else if (openBracketsStack.pop() !== bracketsMap[currentBracket]) {
            return false
        }
    }
    return !openBracketsStack.length
};

```
