Источник: https://www.youtube.com/watch?v=R7LjivfcUGg&ab_channel=%D0%94%D0%96%D0%90%D0%92%D0%90%D0%A1%D0%9A%D0%A0%D0%98%D0%9F%D0%A2%D0%98%D0%97%D0%95%D0%A0%D0%AB%7C%D0%9A%D0%98%D0%A0%D0%98%D0%9B%D0%9B%D0%9F%D0%9E%D0%97%D0%94%D0%9D%D0%AF%D0%9A%D0%9E%D0%92  
27.01.2025  
ЗП: До 250к рублей

# Вопросы
## 1. Что такое Node.js?
Платформа. Платформа для общения Javascript и C++. Там множество составных частей, но самое главное это движок V8 - общение с C++, а также `libuv`.

## 2. Event loop?
Node.js у нас однопоточный, в одном потоке крутятся все задачи.
!!!Почитать про eventloop в Nodejs

### S: А что будет есть в event loop ничего не останется для выполнения?
System exit, мы выйдем

# Алгоритмы
## 3. Знаком с понятием Big О?
Оценка сложности алгоритма.  
У нас есть функция, есть входящий параметр и например мы этот параметр будем оборачивать в цикле. Сколько раз мы будем взаимодействовать с этим параметром, то это у нас и будет `n`.  
Если цикл в цикле и мы перебираем по одному и тому же параметру, то это n^2.  
Если цикл не вложенный стоят рядом с другим циклом, то это будет n+n.  
Все константы, константы вычисления +1, +2 не учитывая.

### S: Что такое `n`?
Количество элементов входящих данных. Например, массив из 100 элементов, то это будет O(100).

## 4. Работал с другими структурами, стэк, очередь?
1. Стэк - по принципу, первый зашел, последний ушел.  
2. Очередь - первый зашел, первый ушел.
3. Списки, есть связанные или двусвязанные списки. Добавляем элемент в конец, у нас есть ссылка на следующий элемент, если это связанный список, если двусвязный то и на предыдущий элемент также.  
4. Деревья
5. Графы - ориентированные, неориентированные

### S: Если взять оценку по времени к доступу к разным стуктурам данным (массиву, списку, hash-таблице)?
1. Hash Map - O(1) - константное время
2. Массив - O(n)
3. Список односвязный - O(n)

# Микросервисы
## 5. Что можешь рассказать о минусах микросервисов?
1. Например, работая с платежками, начинаются проблемы с транзакциями между несколькими микросервисами. Тут есть 2 подхода. Все больше упор на Saga...
2. Трудно воспринимается новичками
3. Оверхедное общение
4. Сетевые проблемы

## 6. Что можешь рассказать про масштабирование? Горизонтальное, вертикальное?
Горизонтальное - кучу реплик одного и того же сервиса.  
Вертикальное - наслаиванием, было CPU 2 ядра, стало CPU 4 ядра. Репликация, шардирование.

## 7. Работал ли с кэшем?
Reddis. Обычно отправлялись данные, они там хранились.

## 8. С какими БД работал?
PostgreSQL, MongoDB, MySQL

## 9. Если будет делаться новый проект и надо выбрать СУБД, что выберешь?
Обычно если много разных данных, они все не структурированы - то они хранились в Mongo, она потом сама разложит.  
PostgreSQL - если данных много, они все важные, которые нельзя терять.  
Если что-то быстрое - то ClickHouse.

## 10. Какие фундаментальные различия между PostgreSQL и MongoDB?
1. PostgreSQL - SQL подход, язык запросов, транзакции, индексы
2. MongoDB - NoSQL, вроде такого нет, там коллекции, неструктурированный подход. Тоже есть транзакции, раньше не было.

## 11. Транзакции, что такое ACID?
1. A - атомарность, выполняет все или ничего 
2. C - неконсистентность, если все данные были в good state до (были нормальными), значит и после будет нормально    
3. I - изолированность, как наши транзакции взаимодействуют друг с другом. Виды: Serializable, read-comitted - read-uncommited, repeatable-read 
4. D - стойкость, если мы записываем данные, то они записаться без хранения промежуточных данных.

# Снова теория
## 12. Знаком ли с принципами SOLID?
1. S - принцип единой ответственности. Класс User должен отвечать только за юзера, без платежек и тд.
2. O - open-closed. Мы можем расширять класс, но не менять ничего.
3. L - Barbara Liskov. Наши классы дочерние, должны быть заменой классов родителей. Взяли дочерний класс - он должен испольнять все что имеет родитель. 
4. I - разделение интерфейсов. Разделяем логику насколько это возможно по 
5. D - dependency invertion. Инверсия зависимостей, наши дочерние не должны влиять на наших родителей + все они должны быть зависимы от абстракций.

# Javascript
## 13. Как работает сборщик мусора в Nodejs?
У нас есть Garbage Collector, мы написали нашу переменную, ссылаемся на эту переменную и где-то ее используем, как только перестаем ссылаться наша перемененая очистится Garbage Collector'ом.  
Там есть умные понятия - типа Heap, помещается в кучу, потом из кучи удаляется. Как только ссылка теряется, то оно удаляется.

## 14.  Есть объект, а он ссылается сам на себя, получается ссылка на него будет жить всегда? Как обработает его сборщик мусора?
Javascript'овый Garbage Collector это умеет, он проверяет все объекты исходя из области видимости из глобального контекста, если у нас переменная видима из глобального контекста, значит ее еще не надо удалять.  
Если есть объект, который будет ссылаться сам на себя, но его не видно из глобального контекста, то этот объект будет помечен для удаления и будет JSом удален.

## 15. Что такое замыкания?
Если простыми словами - это функция в функции. Если не простыми - то это когда наша внутренняя функция замкнута на лексическом окружении родительской функции, условно переменная внутренней функции и мы можем ее там получить.  
Создается область видимости, в которой живут переменные, даже после завершения вызова функции. 

## 16. Если в функцию передаем аргументы, как они передаются? По ссылке, по значению?
Есть ссылочные типа - объект, массив, Set, Map
По значению - примитивы (строки, числа)

## 17. Строки в JS изменяемы?
Они не изменяемы, можем только порождать новые.

# Сети
## 18. Базовые модели ОСи? HTTP какой уровень?
Сетевой - ip4, ip6  
HTTP - на прикладном уровне  
HTTP - сетевой (TCP, UDP), сверху идет TLS чтобы был HTTPS. IP для передачи информации, TCP, UDP - для передачи пакетов. TLS защищает это все.

## 19. В чем различие между TCP и UDP?
TCP гарантирует доставку пакетов, UDP нет. 
! В новых версиях HTTP 3 новый протокол QUICK, основанный на UDP. Быстрее работает, тк в протоколе нету кучи рукопожатий о том что "я тебя слышу", "я знаю что ты меня слышишь" и тд

## 20. Что из себя представляет HTTP запрос?
1. Метод
2. URL
3. Header
4. Body
Изначально метод, url, заголовки, тело.

### S: У каких методов нет тела?
GET, вроде TRACE, OPTIONS без body  
А все на CRUD есть body

## 21. Что такое REST? 
Свод правил по тому как мы общаемся между клиентом и сервером. Есть 6 правил:
1. Разделение на клиент и сервер (клиент ничего не должен знать о сервере, а сервер о клиенте) 
2. Мы не храним состояние на сервере
3. мы должны четко прописывать как мы кешируем
4. Мы должны делать запрос в JSON формате с установленными методами (GET, POST, PUT, PATCH, DELETE)
5. Многослойность, несколько слоев на бэкенде
6. Предоставление предков по запросу (сделали запрос, получили, исполнили)

## 22. Какой HTTP метод для обновления сущности?
По разному, строгих правил нет. В основном PUT, иногда POST. Некоторые говорят про PATCH забыть, некоторые говорят PUT'ом изменяем все, PATCH'им только часть.

## 23. С какими фреймворками на Node.js работал?
Nest, Express, Koa, Fastify

## 24. Из чего состоит Express, какой базовый подход к работе?
Микрофреймворк, то же самое что и Koa, Fastify. Создаем сервер, внутри за основу лежит модуль `http`, который более удобно предоставляет возможность по созданию ручек. Создали `app`, от него уже можно прописывать .get(), .post() и другие параметры.  
Листен запускаем сервер. 

## 25. Какой основной подход к работе у Express?
Сначала middleware, ручка.

## 26. Что использовали для валидации данных?
Joi обычно, в схеме прописывали. Еще есть JSON схемы 

## 27. Писали ли тесты? 
Писал для себя тестирование, интеграционные, юнит, end2end тесты.

## 28. Проводил ли ревью кода?
Да, был свод правил на котором мы основывались. 

## 29. С Docker'ом, K&S работал?
Упаковывали, запускали. 

## 30. Prometheus, Grafana работали?
Да, строили чтобы понимать сервер жив или не жив. 