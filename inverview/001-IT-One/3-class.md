## Классы
Написать класс Human в который передать значение age, затем от него наследоваться Person
```javascript
class Human {
    age;
    
    constructor(age) {
        this.age = age;
    }
    
    logAge() {
        console.log(this.age);
    }
}

class Person extends Human {
    name;

    constructor(age, name) {
        super(age); // Вот тут нужно обязательно передать параметр в super
        this.name = name;
    }
    
    logName() {
        console.log(this.age, this.name);
    }
}

const ivan = new Human(30);
ivan.logAge();

const petya = new Person(25, 'Petya');
petya.logName();

console.log(petya);
// Почему в объекте через console.log не видно logAge() и logName();
```
---

### Давайте разберёмся, почему методы `logAge()` и `logName()` не видн в объекте при выводе в консоль.
### Причина: Методы определены в прототипе, а не как свойства объекта

В JavaScript методы (такие как `logAge()` и `logName()`) обычно определяются в **прототипе класса**, а не как свойства самого объекта. Поэтому они **не отображаются при прямом выводе объекта `console.log(object)`**, так как отображаются только собственные свойства объекта (например, `age` или `name`).

Когда вы создаёте классы через `class` в JavaScript, методы определяются в объекте `prototype`. Это сделано для экономии памяти: если метод не используется как свойство объекта, все экземпляры класса могут использовать одну и ту же копию функции, определённую в прототипе.

### Давайте взглянем на то, что происходит более подробно:

#### Код:
```javascript
console.log(petya);
```

Это покажет объект `petya` со своими **собственными полями**:
```javascript
Person { age: 25, name: 'Petya' } 
```

Здесь видны только **поля** `age` (унаследованное от родительского `Human`) и `name` (установленное в классе `Person`). Нет никаких упоминаний о методах `logAge()` или `logName()`, потому что они находятся в прототипе:

- `logAge` определён в `Human.prototype`
- `logName` определён в `Person.prototype`

Когда вы вызываете, например, `petya.logName()`, движок JavaScript ищет этот метод сначала в собственных свойствах объекта `petya`, а затем в прототипе `Person`. Найдя его, движок выполняет метод.

#### Как увидеть методы объекта

Если хотите увидеть методы, можно воспользоваться такими способами:

1. **Явно проверить прототип объекта:**
   ```javascript
   console.log(Object.getPrototypeOf(petya));
   ```
   Это покажет, что для объекта `petya` прототипом является `Person.prototype`, внутри которого вы найдёте метод `logName`.

2. **Консоль в браузере:**
   Некоторые браузеры (например, Chrome) позволяют визуализировать методы, если вы раскроете скрытые свойства объекта в консоли. Вместо быстрого просмотра объекта кликните на стрелку рядом с ним — это покажет цепочку прототипов.

3. **Эмуляция путём перечисления:**
   Вы можете перечислить свойства и методы (включая унаследованные) через `for...in` или рекурсивный обход по цепочке прототипов.

4. **Вывести прототип напрямую:**
   ```javascript
   console.dir(petya);
   ```

### Полезные советы

- **Разница между свойствами и методами в контексте классов:**
  Если вы хотите, чтобы методы отображались как свойства, можно вручную добавить их в объект